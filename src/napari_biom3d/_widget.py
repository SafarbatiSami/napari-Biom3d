"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""
from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import QHBoxLayout, QPushButton, QWidget
from skimage.util import img_as_float

if TYPE_CHECKING:
    import napari


from pathlib import Path
from magicgui import magicgui
import napari
from napari import Viewer
from napari.layers import Image
import numpy as np
import pathlib
"""" biom3D libs"""
try:
    import biom3d
    from biom3d.preprocess import auto_config_preprocess
    from biom3d.utils import adaptive_load_config # might remove this
    from biom3d.utils import save_python_config # might remove this
    from biom3d.train import train
    from biom3d.pred import pred
    
except:
    print("couldn't import Biom3d's libs")
    pass



"""
@magicgui( directory={"mode": "d", "label": "Choose a directory"})
def preprocess(viewer=Viewer,directory=Path("~")):
  
    print("The directory name is:", directory)
    return directory
"""

         










"""


# Uses the `autogenerate: true` flag in the plugin manifest
# to indicate it should be wrapped as a magicgui to autogenerate
# a widget.
def threshold_autogenerate_widget(
    img: "napari.types.ImageData",
    threshold: "float", 
) -> "napari.types.LabelsData":
    return img_as_float(img) > threshold


# the magic_factory decorator lets us customize aspects of our widget
# we specify a widget type for the threshold parameter
# and use auto_call=True so the function is called whenever
# the value of a parameter changes
@magic_factory(
    threshold={"widget_type": "FloatSlider", "max": 1}, auto_call=True
)
def threshold_magic_widget(
    img_layer: "napari.layers.Image", threshold: "float"
) -> "napari.types.LabelsData":
    return img_as_float(img_layer.data) > threshold


# if we want even more control over our widget, we can use
# magicgui `Container`
class ImageThreshold(Container):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self._viewer = viewer
        # use create_widget to generate widgets from type annotations
        self._image_layer_combo = create_widget(
            label="Image", annotation="napari.layers.Image"
        )
        self._threshold_slider = create_widget(
            label="Threshold", annotation=float, widget_type="FloatSlider"
        )
        self._threshold_slider.min = 0
        self._threshold_slider.max = 1
        # use magicgui widgets directly
        self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

        # connect your own callbacks
        self._threshold_slider.changed.connect(self._threshold_im)
        self._invert_checkbox.changed.connect(self._threshold_im)

        # append into/extend the container with your widgets
        self.extend(
            [
                self._image_layer_combo,
                self._threshold_slider,
                self._invert_checkbox,
            ]
        )

    def _threshold_im(self):
        image_layer = self._image_layer_combo.value
        if image_layer is None:
            return

        image = img_as_float(image_layer.data)
        name = image_layer.name + "_thresholded"
        threshold = self._threshold_slider.value
        if self._invert_checkbox.value:
            thresholded = image < threshold
        else:
            thresholded = image > threshold
        if name in self._viewer.layers:
            self._viewer.layers[name].data = thresholded
        else:
            self._viewer.add_labels(thresholded, name=name)

"""

# SOME UTILS 
class Dict(dict):
    def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs)
    def __getattr__(self, name): return self[name]
    def __setattr__(self, name, value): self[name] = value
    def __delattr__(self, name): del self[name]

def Dict_to_dict(cfg):
    """
    transform a Dict into a dict
    """
    ty = type(cfg)
    cfg = dict(cfg)
    for k,i in cfg.items():
        if type(i)==ty:
            cfg[k] = Dict_to_dict(cfg[k])
    return cfg

def nested_dict_pairs_iterator(dic):
    ''' This function accepts a nested dictionary as argument
        and iterate over all values of nested dictionaries
        stolen from: https://thispointer.com/python-how-to-iterate-over-nested-dictionary-dict-of-dicts/ 
    '''
    # Iterate over all key-value pairs of dict argument
    for key, value in dic.items():
        # Check if value is of dict type
        if isinstance(value, dict) or isinstance(value, Dict):
            # If value is dict then iterate over all its values
            for pair in  nested_dict_pairs_iterator(value):
                yield [key, *pair]
        else:
            # If value is not dict type then yield the value
            yield [key, value]

def nested_dict_change_value(dic, key, value):
    """
    Change all value with a given key from a nested dictionary.
    """
    # Loop through all key-value pairs of a nested dictionary and change the value 
    for pairs in nested_dict_pairs_iterator(dic):
        if key in pairs:
            save = dic[pairs[0]]; i=1
            while i < len(pairs) and pairs[i]!=key:
                save = save[pairs[i]]; i+=1
            save[key] = value
    return dic
# END OF UTILS






# -------------------------------------- Auto configuration --------------------------------------------


@magicgui(call_button="Auto-configure",
            directory1={"mode": "d", "label": "Select the folder containing the images :"},
            directory2={"mode": "d", "label": "Select the folder containing the masks :"})
def autoconfigure(directory1: pathlib.Path,
                    directory2: pathlib.Path,
                    Builder_name="Name for your Builder",
                    
                    Number_classes=1,
                    
                    ):
    
    local_config_dir = "configs"
    local_logs_dir = "logs"
    
    config_path=auto_config_preprocess(img_dir=str(directory1),
        msk_dir=str(directory2),
        desc=Builder_name,
        num_classes=Number_classes,
        remove_bg=False, use_tif=False,
        config_dir=local_config_dir,
        logs_dir=local_logs_dir,
        base_config=None,
            
        )
    return config_path
      
        
# ---------------------------------------- Training --------------------------------------------
  
@magicgui(call_button="Train")        
def training(config_path=None,
             Epochs=10,
             Batch_size=666,
            Patch_size_x=18,
            Patch_size_y=18,
            Patch_size_z=18,
            Augmentation_Patch_size_x=16,
            Augmentation_Patch_size_y=16,
            Augmentation_Patch_size_z=16,
            Number_of_pool_x=57,
            Number_of_pool_y=57,
            Number_of_pool_z=5,):    
    
    local_config_dir = "configs"
    # Read the config file    
    cfg = adaptive_load_config(config_path)
    
    #cfg.DESC = Builder_name
    #cfg.NUM_CLASSES = Number_classes
    #cfg = nested_dict_change_value(cfg, 'num_classes', cfg.NUM_CLASSES)
    
    cfg.NB_EPOCHS = Epochs
    cfg = nested_dict_change_value(cfg, 'nb_epochs', cfg.NB_EPOCHS)
    
    cfg.BATCH_SIZE = Batch_size
    cfg = nested_dict_change_value(cfg, 'batch_size', cfg.BATCH_SIZE)
    
    Patch_size = [int(Patch_size_x),int(Patch_size_y),int(Patch_size_z)]
    cfg.PATCH_SIZE = Patch_size
    cfg = nested_dict_change_value(cfg, 'patch_size', cfg.PATCH_SIZE)
    
    Aug_patch_size = [int(Augmentation_Patch_size_x),int(Augmentation_Patch_size_y),int(Augmentation_Patch_size_z)]
    cfg.AUG_PATCH_SIZE = Aug_patch_size
    cfg = nested_dict_change_value(cfg, 'aug_patch_size', cfg.AUG_PATCH_SIZE)

    Number_of_pools = [int(Number_of_pool_x), int(Number_of_pool_y), int(Number_of_pool_z)]
    cfg.NUM_POOLS = Number_of_pools
    cfg = nested_dict_change_value(cfg, 'num_pools', cfg.NUM_POOLS)
        
     # save the new config file
    new_config_path = save_python_config(
    config_dir=local_config_dir,
    base_config=config_path,
    IMG_DIR=cfg.IMG_DIR,
    MSK_DIR=cfg.MSK_DIR,
    NUM_CLASSES=1,
    BATCH_SIZE=cfg.BATCH_SIZE,
    AUG_PATCH_SIZE=cfg.AUG_PATCH_SIZE,
    PATCH_SIZE=cfg.PATCH_SIZE,
    NUM_POOLS=cfg.NUM_POOLS,
    NB_EPOCHS=cfg.NB_EPOCHS
    
    )
   # run the training           
    train(config=new_config_path)     
        
    return new_config_path



# ------------------------------------ Callback autoconfigure x training -------------------------------------

def autoconfigure_callback(config_path):
    # Read the configuration file
    cfg = adaptive_load_config(config_path)

    # Update the training parameters based on the configuration file
    training.config_path.value = config_path
    #training.Epochs.value = cfg.NB_EPOCHS
    training.Batch_size.value = cfg['BATCH_SIZE']
     # Extracting x, y, z values from PATCH_SIZE and assigning them
    patch_size = cfg.get('PATCH_SIZE', [18, 18, 18])  # Default to [18, 18, 18] if not found
    training.Patch_size_x.value = patch_size[0]
    training.Patch_size_y.value = patch_size[1]
    training.Patch_size_z.value = patch_size[2]

    # Similarly for other parameters
    aug_patch_size = cfg.get('AUG_PATCH_SIZE', [16, 16, 16])
    training.Augmentation_Patch_size_x.value = aug_patch_size[0]
    training.Augmentation_Patch_size_y.value = aug_patch_size[1]
    training.Augmentation_Patch_size_z.value = aug_patch_size[2]

    num_pools = cfg.get('NUM_POOLS', [57, 57, 5])
    training.Number_of_pool_x.value = num_pools[0]
    training.Number_of_pool_y.value = num_pools[1]
    training.Number_of_pool_z.value = num_pools[2]
    
# ------------------------------------------ Predicition -----------------------------------------



@magicgui(call_button="Predict",
          omero_username={"widget_type": "LineEdit", "visible": False, "label": "Omero Username :"},
          omero_password={"widget_type": "Password", "visible": False, "label": "Password :"},
          omero_hostname={"widget_type": "LineEdit", "visible": False, "label": "Hostname :"},
          omero_dataset={"widget_type": "LineEdit", "visible": False, "label": "Input Dataset ID :"},
          omero_project_id={"widget_type": "LineEdit", "visible": False, "label": "Output Project ID :"},
          omero_dataset_name={"widget_type": "LineEdit", "visible": False, "label": "Enter a name for your output dataset :"},
          directory1={"mode": "d", "label": "Select the folder containing the images to predict :"},
          directory2={"mode": "d", "label": "Select the folder containing your model :"},
          directory3={"mode": "d", "label": "Select the output directory for predictions :"},
          )    
def predict(Use_Omero :bool,
            directory1 : pathlib.Path,
            directory2 : pathlib.Path,
            directory3 : pathlib.Path,
            omero_username: str ="",
            omero_password : str="",
            omero_hostname : str ="",
            omero_dataset : int = 0,
            omero_project_id : int = 0,
            omero_dataset_name : str = ""):
    
    predict.omero_username.visible = Use_Omero
    predict.omero_password.visible = Use_Omero
    predict.omero_hostname.visible = Use_Omero
    predict.omero_dataset.visible = Use_Omero
    predict.omero_project_id.visible = Use_Omero
    predict.omero_dataset_name.visible = Use_Omero
    predict.directory3.visible = not Use_Omero
    # Run prediction
    p = pred(dir_in=str(directory1),
        log=str(directory2),
        dir_out=str(directory3))
    # Or use OMERO
   
      
    """
    p=biom3d.omero_pred.run(
                    obj=obj,
                    target="/to_pred",
                    log=str(directory2), 
                    dir_out=str(directory3),
                    user=self.omero_connection.username.get(),
                    pwd=self.omero_connection.password.get(),
                    host=self.omero_connection.hostname.get()
                )  
    """
        
    return p
def on_use_omero_change(widget, value,omero_username,omero_password,omero_hostname, omero_dataset,omero_project_id, omero_dataset_name ,directory1):
    directory1.visible = not value
 
    omero_username.visible = value
    omero_password.visible  = value
    omero_hostname.visible  = value
    omero_dataset.visible  = value
    omero_project_id.visible  = value
    omero_dataset_name.visible  = value
    
################################# --------- WIDGETS CLASSES --------- #################################
class Train(QWidget):
    # your QWidget.__init__ can optionally request the napari viewer instance
    # use a type annotation of 'napari.viewer.Viewer' for any parameter
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer
   
        self.setLayout(QHBoxLayout())
        
        # Connect the autoconfigure callback
        autoconfigure.call_button.changed.connect(lambda: autoconfigure_callback(autoconfigure()))

        viewer.window.add_dock_widget(autoconfigure)
        viewer.window.add_dock_widget(training)
        


class Prediction(QWidget):
    # your QWidget.__init__ can optionally request the napari viewer instance
    # use a type annotation of 'napari.viewer.Viewer' for any parameter
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer
        
        self.setLayout(QHBoxLayout())
        predict.Use_Omero.changed.connect(lambda value: on_use_omero_change(predict, value, predict.omero_username, predict.omero_password, predict.omero_hostname, predict.omero_dataset,predict.omero_project_id, predict.omero_dataset_name, predict.directory1))


        viewer.window.add_dock_widget(predict)
     
    
    